<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="彤哥哥的博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://ltyeamin.github.io">
    <!--SEO-->

    <meta name="keywords" content="Java">


    <meta name="description" content="最近在使用Spring Cloud过程中,经常会遇见线程隔离(切换).导致ThreadLocal数据丢失.例如调用其他服务获取不到Threadlocal没有数据,服务之间传递请求头传递失败.通过...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>线程切换导致ThreadLocal数据丢失分析 | 彤哥哥的博客</title>


    <link rel="alternate" href="/atom.xml" title="彤哥哥的博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">


<script src="/js/jquery.min.js"></script>
    <link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">
<link rel="stylesheet" href="/css/calendar.css?rev=@@hash">
<link rel="stylesheet" href="/css/variable.css?rev=@@hash">
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ebfd000c0e7cc1ee84a00f01d419b1e2";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="YeaMin">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://ltyeamin.github.io">彤哥哥的博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa"></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/backend/"><i class="fa"></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/frontend/"><i class="fa"></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/ops/"><i class="fa"></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/database/"><i class="fa"></i>数据库</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/algorithm/"><i class="fa"></i>算法</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/pm/"><i class="fa"></i>项目管理</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href=""><i class="fa"></i>自媒体</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/others/"><i class="fa"></i>生活</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/about"><i class="fa /favicon.ico"></i>关于</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="线程切换导致ThreadLocal数据丢失分析">
            
	            线程切换导致ThreadLocal数据丢失分析
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/backend/">backend</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/Java/">Java</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/03/15</span>
        </span>
        
            <span class="fa-wrap">
                <i class="fa fa-eye"></i>
                <span id="busuanzi_value_page_pv"></span>
            </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>483</strong>天之前发表，文中内容可能已经过时
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p>最近在使用Spring Cloud过程中,经常会遇见线程隔离(切换).导致ThreadLocal数据丢失.例如调用其他服务获取不到Threadlocal没有数据,服务之间传递请求头传递失败.通过查阅相关文档才发现:<br>用Hystrix实现断路器,Zuul中默认使用的是信号量,其他默认都是线程隔离.具体文档如下(可参考<a href="https://github.com/Netflix/Hystrix/wiki/Configuration#executionisolationstrategy" target="_blank" rel="noopener">Hystrix WIKI</a>)：</p>
<blockquote>
<p>Thread or Semaphore</p>
<ul>
<li>The default, and the recommended setting, is to run HystrixCommands using thread isolation (THREAD) and HystrixObservableCommands using semaphore isolation (SEMAPHORE).</li>
<li>Commands executed in threads have an extra layer of protection against latencies beyond what network timeouts can offer.</li>
<li>Generally the only time you should use semaphore isolation for HystrixCommands is when the call is so high volume (hundreds per second, per instance) that the overhead of separate threads is too high; this typically only applies to non-network calls.</li>
</ul>
</blockquote>
<p>在使用线程隔离的时候，有个问题是必须要解决的，那就是在某些业务场景下通过ThreadLocal来在线程里传递数据，用信号量是没问题的，从请求进来，但后续的流程都是通一个线程。<br>当隔离模式为线程时，Hystrix会将请求放入Hystrix的线程池中去执行，这个时候某个请求就有A线程变成B线程了，ThreadLocal必然消失了.</p>
<h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class CustomThreadLocal &#123;</span><br><span class="line">    static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                CustomThreadLocal.threadLocal.set(&quot;彤哥哥&quot;);</span><br><span class="line">                new Service().call();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Service &#123;</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;Service:&quot; + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(&quot;Service:&quot; + CustomThreadLocal.threadLocal.get());</span><br><span class="line">        new Dao().call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dao &#123;</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;==========================&quot;);</span><br><span class="line">        System.out.println(&quot;Dao:&quot; + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(&quot;Dao:&quot; + CustomThreadLocal.threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在主类中定义了一个ThreadLocal用来传递数据，然后起了一个线程，在线程中调用Service中的call方法，并且往Threadlocal中设置了一个值，在Service中获取ThreadLocal中的值，然后再调用Dao中的call方法，也是获取ThreadLocal中的值，我们运行下看效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Service:Thread-0</span><br><span class="line">Service:彤哥哥</span><br><span class="line">==========================</span><br><span class="line">Dao:Thread-0</span><br><span class="line">Dao:彤哥哥</span><br></pre></td></tr></table></figure></p>
<p>从运行结果来看,同一个线程中能够获得ThreadLocal的值.这个没错,接下来,将Serice类中的call()方法稍微改造一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void call() &#123;</span><br><span class="line">    System.out.println(&quot;Service:&quot; + Thread.currentThread().getName());</span><br><span class="line">    System.out.println(&quot;Service:&quot; + CustomThreadLocal.threadLocal.get());</span><br><span class="line">    //new Dao().call();</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            new Dao().call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次运行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Service:Thread-0</span><br><span class="line">Service:彤哥哥</span><br><span class="line">==========================</span><br><span class="line">Dao:Thread-1</span><br><span class="line">Dao:null</span><br></pre></td></tr></table></figure></p>
<p>由此可见是两个不同的线程,在运行Dao中的call()方法进行了线程切换,所以ThreadLocal获取到的数据未null.</p>
<h2 id="InheritableThreadLocal引入"><a href="#InheritableThreadLocal引入" class="headerlink" title="InheritableThreadLocal引入"></a>InheritableThreadLocal引入</h2><p>既然遇到问题就该解决,那么如何解决呢?<br>其实解决起来很简单,只需要改一行代码即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static ThreadLocal&lt;String&gt; threadLocal = new InheritableThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>将Threadlocal改成子类InheritableThreadLocal后运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Service:Thread-0</span><br><span class="line">Service:彤哥哥</span><br><span class="line">==========================</span><br><span class="line">Dao:Thread-1</span><br><span class="line">Dao:彤哥哥</span><br></pre></td></tr></table></figure></p>
<p>非常完美的解决了线程切换导致ThreadLocal拿不到值而产生的问题.</p>
<h2 id="深入InheritableThreadLocal原理"><a href="#深入InheritableThreadLocal原理" class="headerlink" title="深入InheritableThreadLocal原理"></a>深入InheritableThreadLocal原理</h2><p>要先了解InheritableThreadLocal原理,首先清楚ThreadLocal的原理.话不多说,先分析一下ThreadLocal的原理:</p>
<ul>
<li><p>每个线程都有一个ThreadLocalMap类型的threadLocals属性,ThreadLocalMap类相当于一个Map,key 是 ThreadLocal本身,value就是我们设置的值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们通过threadLocal.set(“彤哥哥”)的时候,就是在这个线程中的threadLocals属性中放入一个键值对,key是 当前线程,value就是你设置的值。</p>
</li>
<li>当我们通过 threadlocal.get()方法的时候,就是根据当前线程作为key来获取这个线程设置的值.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocal&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        //获取当前的线程对象</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        //获取当前线程对象中的threadLocals属性</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">        return t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过上面的介绍我们可以了解到threadlocal能够传递数据是用Thread.currentThread()当前线程来获取,也就是只要在相同的线程中就可以获取到前面设置进去的值.<br>如果在threadlocal设置完值之后,下步的操作重新创建了一个线程,这个时候Thread.currentThread()就已经变了,那么肯定是拿不到之前设置的值.具体的问题复现可以参考上面我的代码.<br>那为什么InheritableThreadLocal就可以呢?<br>InheritableThreadLocal这个类继承了ThreadLocal,重写了3个方法,在当前线程上创建一个新的线程实例Thread时,会把这些线程变量从当前线程传递给新的线程实例.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    protected T childValue(T parentValue) &#123;</span><br><span class="line">        return parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">       return t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我们可以看到InheritableThreadLocal 重写了childValue, getMap,createMap三个方法,我们往里面set值的时候,值保存到了inheritableThreadLocals里面,而不是之前的threadLocals<br>那么关键的点来了,为什么当创建新的线程池,可以获取到上个线程里的threadLocal中的值呢?原因就是在新创建线程的时候,会把之前线程的inheritableThreadLocals赋值给新线程的inheritableThreadLocals,通过这种方式实现了数据的传递.<br>源码最开始在Thread的init()方法中,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public</span><br><span class="line">class Thread implements Runnable &#123;</span><br><span class="line">    private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                      long stackSize, AccessControlContext acc,</span><br><span class="line">                      boolean inheritThreadLocals) &#123;</span><br><span class="line">        //代码省略......              </span><br><span class="line">        if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)</span><br><span class="line">             //创建新的ThreadLocalMap并复制给当前线程的inheritableThreadLocals对象</span><br><span class="line">            this.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        //代码省略......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">        return new ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 赋值代码</span><br><span class="line">     */</span><br><span class="line">     private ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">        Entry[] parentTable = parentMap.table;</span><br><span class="line">        int len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line">        table = new Entry[len];</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = parentTable[j];</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                if (key != null) &#123;</span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line">                    Entry c = new Entry(key, value);</span><br><span class="line">                    int h = key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                    while (table[h] != null)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此为止,通过inheritableThreadLocals我们可以在父线程创建子线程的时候将Local中的值传递给子线程,这个特性已经能够满足大部分的需求了.<br>但是还有一个很严重的问题是如果是在线程复用的情况下就会出问题,比如线程池中去使用inheritableThreadLocals进行传值,因为inheritableThreadLocals 只是会再新创建线程的时候进行传值,<br>线程复用并不会做这个操作,那么要解决这个问题就得自己去扩展线程类实现这个功能.</p>
<h2 id="阿里解决之道"><a href="#阿里解决之道" class="headerlink" title="阿里解决之道"></a>阿里解决之道</h2><p>开源的世界应有尽有,为了解决上述遗留的问题,阿里开源了一款Java框架: <a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">transmittable-thread-local</a><br>其主要功能就是解决在使用线程池等会缓存线程的组件情况下,提供ThreadLocal值的传递功能,解决异步执行时上下文传递的问题.<br>JDK的InheritableThreadLocal类可以完成父线程到子线程的值传递.但对于使用线程池等会缓存线程的组件的情况,线程由线程池创建好,并且线程是缓存起来反复使用的;<br>这时父子线程关系的ThreadLocal值传递已经没有意义,应用需要的实际上是把任务提交给线程池时的ThreadLocal值传递到任务执行时.<br>transmittable-thread-local使用方式分为三种:修饰Runnable和Callable,修饰线程池,Java Agent来修饰JDK线程池实现类.<br>接下来给大家演示下线程池的修饰方式,首先来一个非正常的案例,代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class CustomThreadLocal &#123;</span><br><span class="line"></span><br><span class="line">    static ThreadLocal&lt;String&gt; threadLocal = new InheritableThreadLocal&lt;&gt;();</span><br><span class="line">    /**</span><br><span class="line">     * 创建一个固定大小为2的线程池</span><br><span class="line">     */</span><br><span class="line">    static ExecutorService pool = Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i=0;i&lt;100;i++) &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            pool.execute(new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    CustomThreadLocal.threadLocal.set(&quot;彤哥哥&quot;+j);</span><br><span class="line">                    new Service().call();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Service &#123;</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        CustomThreadLocal.pool.execute(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                new Dao().call();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dao &#123;</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;Dao:&quot; + CustomThreadLocal.threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上面的代码,出现的结果是不正确的,输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Dao:彤哥哥99</span><br><span class="line">Dao:彤哥哥99</span><br><span class="line">Dao:彤哥哥62</span><br><span class="line">Dao:彤哥哥99</span><br><span class="line">Dao:彤哥哥62</span><br><span class="line">Dao:彤哥哥99</span><br><span class="line">Dao:彤哥哥99</span><br><span class="line">Dao:彤哥哥62</span><br><span class="line">Dao:彤哥哥99</span><br><span class="line">Dao:彤哥哥62</span><br><span class="line">Dao:彤哥哥62</span><br><span class="line">Dao:彤哥哥99</span><br><span class="line">省略之后的结果...</span><br></pre></td></tr></table></figure></p>
<p>正确的应该是从0-99不能有重复,由于线程的复用,值被替换掉了才会出现不正确的结果.<br>接下来使用transmittable-thread-local来改造有问题的代码,添加transmittable-thread-local的Maven依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;transmittable-thread-local&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>只需要修改2个地方,修饰线程池和替换InheritableThreadLocal:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static TransmittableThreadLocal&lt;String&gt; threadLocal = new TransmittableThreadLocal&lt;&gt;();</span><br><span class="line">static ExecutorService pool =  TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(2));</span><br></pre></td></tr></table></figure></p>
<p>正确结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Dao:彤哥哥1</span><br><span class="line">Dao:彤哥哥2</span><br><span class="line">Dao:彤哥哥4</span><br><span class="line">Dao:彤哥哥5</span><br><span class="line">Dao:彤哥哥3</span><br><span class="line">Dao:彤哥哥6</span><br><span class="line">Dao:彤哥哥7</span><br><span class="line">Dao:彤哥哥8</span><br><span class="line">Dao:彤哥哥9</span><br><span class="line">Dao:彤哥哥10</span><br><span class="line">Dao:彤哥哥11</span><br><span class="line">省略之后的结果...</span><br></pre></td></tr></table></figure></p>
<p>到这里我们就已经可以完美的解决线程中,线程池中ThreadLocal数据的传递了,题主趁着中午喝茶的时间,无意间找到其他解决方案,下节继续用其他方式进行解决.</p>
    </div>
    
        <div class="reward" ontouchstart="">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="/about/alipay.png"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="/about/weixin.png"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">请作者喝杯咖啡吧</p>

    <!-- 社会分享工具 -->
    <div class="bdsharebuttonbox">
         <a href="#" class="bds_more" data-cmd="more"></a>
         <a href="#" class="bds_qzone" data-cmd="qzone"></a><a href="#" class="bds_tsina" data-cmd="tsina"></a>
         <a href="#" class="bds_tqq" data-cmd="tqq"></a><a href="#" class="bds_renren" data-cmd="renren"></a>
         <a href="#" class="bds_weixin" data-cmd="weixin"></a>
    </div>
     <script>
        window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
     </script>
</div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">彤哥哥</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/03/27/单例模式-Spring单例实现原理分析/" class="pre-post btn btn-default" title="单例模式-Spring单例实现原理分析">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">单例模式-Spring单例实现原理分析</span>
        </a>
    
    
        <a href="/2018/02/07/使用Jenkins进行持续集成/" class="next-post btn btn-default" title="使用Jenkins进行持续集成">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">使用Jenkins进行持续集成</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'wA3iNQOiAuhrRJkNgIjirA8f-gzGzoHsz',
            appKey: 'iGL0JyEnJQ8HIMlLd4Sm0oOp',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail,link'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>
    </div>
                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟实现"><span class="toc-text">模拟实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InheritableThreadLocal引入"><span class="toc-text">InheritableThreadLocal引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深入InheritableThreadLocal原理"><span class="toc-text">深入InheritableThreadLocal原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阿里解决之道"><span class="toc-text">阿里解决之道</span></a></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
        访问量:
        <strong id="busuanzi_value_site_pv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
        &nbsp; | &nbsp;
        访客数:
        <strong id="busuanzi_value_site_uv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
    
</div>
            </div>
            <div>
                <!-- 服务器运行时间统计 -->
                <span id="sitetime"></span>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019
                </span> |
                <span>
                    Powered by <a href="//ltyeamin.github.io" class="copyright-links" target="_blank" rel="nofollow">litong</a>
                </span> |
                <span>
                    Blog by <a href="//ltyeamin.github.io" class="copyright-links" target="_blank" rel="nofollow">彤哥哥</a>
                </span>
            </div>
        </div>
    </div>
</div>


<script src="/assets/tagcanvas.min.js?rev=2.9"></script>
    <script>
        var tagOption = {
            textColour: '#e67e22', // 字体颜色
            outlineMethod: 'block', // 选中模式
            outlineColour: '  #FDF5E6', // 选中模式的颜色
            interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
            textHeight: 13,
            outlineRadius: 3,
            freezeActive: true || '', // 选中的标签是否继续滚动
            frontSelect: true || '', // 不选标签云后部的标签
            initial: [0.1, -0.1],
            depth: 0.5,
            decel: 0.95,
            maxSpeed: 0.03,
            reverse: true || '', // 是否反向触发
            fadeIn: 500, // 进入动画时间
            wheelZoom: true || '' // 是否启用鼠标滚轮
        }
        TagCanvas.Start('tag-cloud-3d','',tagOption);
    </script>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash"></script>
<!-- 页面点击小红心，在末尾添加，避免找不到 -->
<script type="text/javascript" src="/js/love.js"></script>

<!-- DaoVoice即时通讯工具 -->

 <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "10b503a1"
    });
  daovoice('update');
  </script>


<!-- 音频播放 
<link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>
-->

<!-- 服务器运行时间统计 -->
<script language="javascript">
        function siteTime(){
          window.setTimeout("siteTime()", 1000);
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth()+1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
          year - 作为date对象的年份，为4位年份值
          month - 0-11之间的整数，做为date对象的月份
          day - 1-31之间的整数，做为date对象的天数
          hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
          minutes - 0-59之间的整数，做为date对象的分钟数
          seconds - 0-59之间的整数，做为date对象的秒数
          microseconds - 0-999之间的整数，做为date对象的毫秒数 */
          var t1 = Date.UTC(2016,12,1,00,00,00); //北京时间2016-12-1 00:00:00
          var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
          var diff = t2-t1;
          var diffYears = Math.floor(diff/years);
          var diffDays = Math.floor((diff/days)-diffYears*365);
          var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
          var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
          var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
          document.getElementById("sitetime").innerHTML=" 本站已运行 "+ diffYears+" 年 "+ diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分 "+diffSeconds+" 秒";
        }
        siteTime();
</script>
</body>
